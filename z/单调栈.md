---
tags:
  - tech/lang/algorithm
  - type/concept
  - status/growing
description: 单调栈数据结构原理与应用场景
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[Algorithm MOC]] | [[数据结构 MOC]]

---


# 单调栈 

> 他向远方望去，无法看到高山背后的矮山，只看到一座座更高的山峰。

## 场景

一个记录了每天温度的数组，只想知道上升的节点。

## 特性

加入新数据时，保持栈中元素的单调性（递增/递减）

## 模板

```js
/**
 * @param {number[]} nums
 * @return {number[][]}  [[left...], [right...]]
 */
function nearestGreater(nums) {
    const n = nums.length;
    const left = new Array(n).fill(-1);
    const right = new Array(n).fill(n);

    // 单调栈（递减栈）求左侧最近严格大于的下标
    const stackL = [];               // 栈中保存下标
    // 哨兵 -1 放在栈底，便于统一判断
    stackL.push(-1);
    for (let i = 0; i < n; i++) {
        const x = nums[i];
        // 栈顶元素对应的值 <= 当前值 时弹出（因为我们只保留严格更大的元素）
        while (stackL.length > 1 && nums[stackL[stackL.length - 1]] <= x) {
            stackL.pop();
        }
        left[i] = stackL[stackL.length - 1]; // 栈顶即为左侧最近严格大于的下标
        stackL.push(i);
    }

    // 单调栈求右侧最近严格大于的下标（从右往左遍历）
    const stackR = [];
    stackR.push(n);                  // 哨兵 n 放在栈底
    for (let i = n - 1; i >= 0; i--) {
        const x = nums[i];
        while (stackR.length > 1 && nums[stackR[stackR.length - 1]] <= x) {
            stackR.pop();
        }
        right[i] = stackR[stackR.length - 1];
        stackR.push(i);
    }

    return [left, right];
}

/* 示例 */
const arr = [3, 1, 4, 2, 5];
console.log(nearestGreater(arr));
/*
输出：
[
  [ -1, 0, -1, 2, -1 ],   // left
  [ 2, 2, 4, 4, 5 ]       // right（5 为 nums.length，表示不存在）
]
*/
```

## 题单

- [[每日温度]]
## 其他

- 矩形
- 贡献法
- 最小字典序
