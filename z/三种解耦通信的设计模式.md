---
tags:
  - tech/dev/pattern
  - type/concept
  - status/growing
description: 三种解耦通信的设计模式
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[设计模式 MOC]] | [[项目实践 MOC]]

---


## 观察者模式（Observer Pattern）

**核心思想：**  
定义对象间的一对多的依赖关系，当被观察者（Subject）状态变化时，自动通知所有观察者（Observer）并触发更新。

**角色：**

- Subject： 维护观察者列表，提供添加、移除和通知方法。
- Observer： 实现统一的更新接口。

**特点：**

- 直接耦合： Subject 要直接管理 Observer，双方知晓对方存在。

## 发布订阅模式（Pub-Sub）

**核心思想：**  
通过中介（事件中心）解耦发布者（Publisher）和订阅者（Subscriber），发布者不关心订阅者是否存在，订阅者也只关注事件类型。

**角色：**

- Publisher： 发布消息到事件中心。
- Subscriber： 订阅事件并定义回调。
- Event Center： 管理事件分发。

**特点：**

- 完全解耦： 双方无需知道彼此，通过事件中心通信。
- 多对多通信

**应用场景：**  
消息队列（Kafka、RabbitMQ）、微服务异步通信、分布式系统

## 事件驱动（Event-Driven）

**核心思想：**  
程序的执行流程由事件触发，组件通过事件监听和响应实现异步协作。

**角色：**

- 事件源： 发送事件。
- 监听器： 监听事件，并处理。
- 事件总线。

**特点：**

- 事件源和监听器分离：类似观察者，但更强调事件的生命周期和异步处理
- 动态注册：监听器可灵活注册/注销事件。

**应用场景：**  
交互式系统

## 总结

观察者 和 发布订阅 是具体设计模式，而 事件驱动 是更高层的架构思想。  
可以用 前两种设计模式 来实现 事件驱动。  

Vue 中的 `emit` 和 Electron 中的进程间通信就是一种用 发布订阅模式 来实现 事件驱动 的  

不同的是 Vue 中的是同一进程内的通信，属于应用层事件驱动；而 Electron 中的是跨进程的，使用了操作系统的进程通信机制（消息队列、管道、命名管道）

Vue 中的 数据响应式更新 则是用到了观察者模式：
把数据劫持后作为被观察的对象，然后维护一个 Dep 实例来收集依赖（观察者），当数据更新后，通知所有观察者，让他们调用自身的更新方法。  
