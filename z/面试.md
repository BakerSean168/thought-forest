---
tags:
  - life/work
  - type/resource
  - status/growing
description: 前端面试知识点汇总(TreeShaking/性能优化等)
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[职业发展 MOC]] | [[前端基础 MOC]]

---

### Tree Sharking

Tree Shaking（摇树优化）是一种用于优化 JavaScript 应用的静态代码分析技术，其核心目标是通过移除未使用的代码（即“死代码”）来减小最终打包文件的体积，从而提升应用加载速度和运行性能。这一概念最早由 Rollup 提出，现已成为现代前端构建工具（如 Webpack、Rollup、Vite 等）的标配功能。  

核心原理：  
- 基于 ES6 模块的静态分析  
  Tree Shaking 依赖于 ES6 模块（ESM）的静态结构特性（import/export），因为 ESM 的依赖关系在编译时即可确定，而非像 CommonJS 模块那样动态解析。这使得构建工具能够通过抽象语法树（AST）分析代码的导出与引用关系，精确识别未使用的模块或变量。  
  若模块导出了 A 和 B，但仅 A 被其他模块引用，则 B 会被移除。  
- 死代码消除（DCE）的进阶形式  
  传统 DCE 仅移除不可能执行的代码（如未调用的函数），而 Tree Shaking 更关注未引用的模块或导出值。  
- 与副作用（Side Effects）的关联  
  若模块包含副作用（如修改全局变量、立即执行函数等），Tree Shaking 会保留这些代码以避免破坏程序逻辑。开发者可通过 package.json 的 "sideEffects" 字段显式标记这类模块（如 CSS 文件）。
  
### Rollup

Rollup 是一款专注于 JavaScript 模块打包 的工具，由 Rich Harris（Svelte 作者）开发。它的设计理念与 Webpack 有显著不同，更强调 轻量、高效和面向未来的模块化代码。  

核心设计理念：  
- 面向 ESM  
- Tree Shaking 优先  
- 简单高效  
- 适合库/框架开发  

核心特性：  
- Tree Shaking  
- 输出格式灵活  
- 插件系统  
- 代码分割  

### ref 和 reactive

| 特性     | `ref`                           | `reactive`         |
| -------- | ------------------------------- | ------------------ |
| 数据类型 | 所有类型                        | 仅对象类型         |
| 访问方式 | 需 `.value`（模板自动解包）     | 直接访问属性       |
| 实现原理 | `RefImpl` + 内部调用 `reactive` | Proxy 代理         |
| 对象替换 | 支持                            | 不支持             |
| 深层监听 | 需显式启用 `deep: true`         | 默认支持           |
| 适用场景 | 基本类型、灵活替换对象          | 复杂对象、嵌套结构 |

### Vite 和 Webpack

Vite：  
- 开发环境无需打包，速度快
- 生产环境使用 Rollup 打包，支持 Tree Shaking、代码分割等优化  
- 热更新效率高  

Webpack：  
- 全程打包  
- 成熟的生态系统，支持复杂的代码分割、插件扩展和旧浏览器兼容。  



### 进程、线程、协程

#### 进程  

定义：  
- 操作系统进行资源分配和调度的基本单位，是程序运行的实例，拥有独立的内存空间和系统资源。  

#### 线程

定义：  
- 进程内的执行单元，是 CPU 调度的基本单位。  
- 一个进程可以包含多个线程，共享进程的资源  
- 每个线程有自己的栈和寄存器  

特点：  
- 轻量  
- 共享资源  
- 不安全  
  一个线程崩溃可能导致整个进程崩溃  

##### 线程间的通信方式

等待-通知机制  
消息队列  
join 机制  

##### 进程间的通信方式

高级通信机制可归结为四大类： 共享存储器系统、管道通信系统、消息传递系统、客户机-服务器系统  

#### 协程  

定义：  
- 用户态的轻量级进程  
- 程序自身调度  

特点：  
- 极低开销  
- 非抢占式调度  
- 无并行能力  

### docker 与 虚拟机 的区别

#### docker

基于容器技术，共享宿主机的操作系统内核  
通过命名空间（Namespace）和控制组（Cgroup）实现资源隔离  
容器本质上是宿主机的进程  
资源利用率高（硬件利用率可达60%-80%）  
启动速度秒级  
镜像体积小（通常为MB级）  
进程级隔离，安全性较弱  

典型应用场景：  
- 开发环境一致  
- 微服务架构  
- 跨平台应用分发  
- 临时测试环境  

#### 虚拟机

Hypervisor 虚拟化硬件  
运行完整操作系统  
资源消耗大  
启动分钟级  
镜像体积大  
操作系统级隔离  

### SSR 应用

优点：  
- SEO 友好  
  搜索引擎爬虫可以直接抓取服务端生成的完整HTML内容，无需依赖客户端JavaScript执行，显著提升搜索引擎收录效果
- 首屏加载速度快  
  服务器直接返回渲染后的 HTML  
- 低端设备兼容性  
- 内容一致性  

问题：  
- 服务器性能压力  
- 开发复杂度  
- 安全风险  
- 流失渲染与性能优化  
- 部署与运维成本  

### js 有哪些 worker（Web Worker）

Web Worker是HTML5标准的一部分，允许在主线程外创建独立的后台线程（Worker线程）。这些线程与主线程并行运行，不共享内存和DOM，但可通过消息传递机制（postMessage和onmessage）进行通信。  

JavaScript提供了多种 Worker 机制来实现多线程编程  
- Web Workers / Dedicated Workers(专用Worker)：  
  最基本的Worker类型，由主线程创建并专属于创建它的脚本  
  无法访问DOM，通过postMessage与主线程通信  
  适用于CPU密集型计算任务  
- Shared Workers(共享Worker)：  
  可以被多个浏览上下文(不同窗口、iframe等)共享  
  适用于需要跨窗口/标签页共享数据和状态的场景  
- Service Workers：  
  主要用作网络代理，可拦截和处理网络请求  
- Worklets：  
  轻量级专用Worker，用于扩展渲染管道  
- Node.js中的Worker Threads：  
  允许在Node.js中使用真正的多线程  

worker 通信：  
- 通信机制  
  结构化克隆  
  共享内存  
- 使用限制  
  无法操作 DOM  
  同源策略  
  生命周期管理  

### Electron 底层有几个线程  

- 主进程  
- 渲染进程  
- GPU 进程  
- 插件进程  
- 实用程序进程  

#### Cookie

设置存储时间：  
- expires  
  绝对时间  
- max-age  
  相对时间  

存储位置：  
未设置过期时间：会话 Cookie（内存中，关闭浏览器失效）。  
设置过期时间：持久化 Cookie（硬盘中）。  

#### localStorage

使用 localStorage.clear() 方法可以一次性清空当前域名下的所有 localStorage 数据  
通过 localStorage.removeItem(key) 删除特定键值对  
使用函数模拟定期清除  

场景：  
- 用户数据持久化、偏好设置  
- 本地缓存、性能优化  
- 离线应用程序支持  
- 跨页面数据传递  
- 用户登录状态与身份验证  
- 表单数据自动填充  
- 跨标签页通信（监听 storage 事件）  

### PWA

渐进式增强(Progressive Enhancement)  
关键技术组件：  
- Service Worker  
  这是PWA的核心技术之一，负责离线缓存、推送通知、后台同步等功能。Service Worker是一段独立的JavaScript脚本，可以在后台处理网络请求，缓存数据和推送通知   
- Web App Manifest  
  一个JSON文件，用于描述PWA应用的名称、图标、启动URL等信息，让浏览器可以将Web应用添加到主屏幕   
- HTTPS  
  PWA必须通过HTTPS协议提供服务，确保用户数据的安全  
- Push API  
  用于向用户发送推送通知  
- Cache API  
  用于缓存静态资源  

工作原理：  
- 拦截网络请求  
  Service Worker可以拦截应用发出的所有HTTP请求  
- 缓存策略  
  开发者可以自定义缓存策略，决定哪些资源应该被缓存以及如何响应缓存和网络请求  
- 离线支持  
- 后台同步  

### 响应式设计的实现方式

响应式设计（Responsive Web Design, RWD）的核心是通过动态调整布局、内容和功能，使网页适配不同设备的屏幕尺寸和分辨率。  

关键技术：  
- 流式布局  
  使用百分比、vw/vh等相对单位替代固定像素，使元素尺寸随容器或视口变化。  
- 媒体查询  
  通过CSS检测设备特性（如屏幕宽度、方向），应用不同的样式规则。  
- 弹性媒体  
  图片和视频使用max-width: 100%或srcset属性，按需加载适配尺寸的资源。  

## 前端工程化

- 性能优化
- RestFul API
- 虚拟DOM、真实DOM

## CSS

- 盒模型
- 弹性盒子
- 垂直居中
- 选择器（类型、权重）

## JS

- 原型链
- 闭包
- ES6 新特性
- EventLoop（概念、输入输出）
- 箭头函数
- this 指向
- Var 变量提升

## Vue

- Vue2、Vue3区别

## React

6. 你知道react的fiber架构吗？hook-useFiber
7.  React用函数式组件怎么模拟出生命周期
8.  useLayoutEffect和useEffect有什么区别

作者：想去夏威夷的土拨鼠在攒经验
链接：https://www.nowcoder.com/feed/main/detail/39249e4d6def4f15bd1c7400f927f37b?sourceSSR=enterprise
来源：牛客网

## 浏览器

- 浏览器缓存机制
- 浏览器两个Tab页之间要怎么跨页面通信
- 浏览器垃圾回收机制

## 场景

- 在做大文件分片上传的时候，每一个文件的唯一标识要怎么去获得呢？

## 算法

- 链表反转
- 最长公共子序列
- dfs找最大岛屿
- 找最长不重复子串

## 计算机网络

https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md

- OSI 和 TCP/IP 网络分层模型，每一层的作用
- URL 输入到页面渲染
- TCP、UDP
- http、https
- tls

TCP的三次握手
- 流程
- 半连接和全连接
- 为什么要三次握手
- 三次握手可以携带数据吗

TCP 的四次挥手
- 流程
- 为什么要四次挥手
- 能不能合并第二次和第三次  
- 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态  

TCP 传输可靠性保障
- 如何保障
- 流量控制
- 拥塞控制
- ARQ 协议
- 超时重传


HTTP/0.9
最初想法是将文档存在服务器中，我们只需要从服务器获取存档  
所以只有 GET，也没有请求头，并且请求完连接就断了  

### HTTP 1.0 和 HTTP 2.0 有什么区别

HTTP/1.0  
- 增加了 HEAD、POST 等新方法
- 增加了响应状态码
- 引入了头部（请求头、响应头）  
- 在请求中加入了 HTTP 版本号  
- 引入了 Content-Type， 使传输数据不再局限于文本  

HTTP/1.1
- 新增连接管理（keepalive），允许持久连接。
- 支持 pipeline ，无需等待前面的请求响应，即可发送第二次请求。  
- 允许响应数据分块，即响应的时候不标明 Content-Length，客户端就无法断开连接，直到收到服务端的 EOF ，利于大文件传输
- 新增缓存的控制和管理  
- 加入 Host 头，用在一台机子部署多个主机，多个域名解析又是同一个 IP，此时加入 Host 头就可以判断要访问哪个主机  

HTTP/2
- 变为二进制协议，不再是纯文本
- 支持一个 TCP 连接发起多请求，移除了 pipeline  
- 利用 HPACK 压缩头部，减少数据传输量  
- 允许服务端主动推送数据  

HTTP 2.0 和 3.0 有什么区别？
- 基于UDP协议
- 支持1-RTT 或 0-RTT 连接
- 多路复用+轮询
- 更高效的 QPACK 头部压缩算法
- 连接迁移  
- 错误恢复
- 整个数据包加密

常见的 HTTP 状态码有哪些？

HTTP 请求包含哪些内容，请求头和请求体有哪些类型？

HTTP 中 GET 和 POST 的区别是什么？
- 语义
- 幂等
- 请求参数位置
- 安全性
- 缓存

WebSocket 与 HTTP 有什么区别？
- WebSocket 也是一个应用层的协议，基于 TCP。  
- 支持实时双向通信
- 协议前缀
- 通信数据格式较轻量
- 支持扩展

服务端是如何解析 HTTP 请求的数据？（考察 HTTP 请求格式的了解程度）
- 接收请求
- 解析请求行
- 解析请求头
- 处理请求题
- 提取查询参数和路径参数
- 处理Cookie和会话
- 路由和业务逻辑处理
- 生成响应
- 发送响应并关闭连接

TCP 的粘包和拆包能说说吗？
  TCP 是面向字节流的协议，他只保证数据可靠传输，不维护消息边界。  

  粘包  
    定义：  
      多个数据包被合并成一个 TCP 段发送，接收方一次性读取到多个包的数据。  
    原因：  
      发送方：Nagle 算法（默认启用）会合并多个小数据包以提高网络效率。  
      接收方：缓冲区数据堆积，导致多个包被一次性读取。  
  拆包  
    定义：  
      一个数据包被拆分成多个 TCP 段发送，接收方需要多次读取才能拼凑完整数据。  
    原因：  
      发送方：数据包超过 MSS（Maximum Segment Size，通常 1460 字节）。  
      接收方：缓冲区大小不足，导致部分数据被截断。  

  解决方法：  
  - 固定消息长度，不足补充`\0`  
  - 使用特殊分隔符标记结束  
  - 消息头写消息长度，消息体存储数据  
  
TCP 初始序列号 ISN 怎么取值的？
  ISN 的基本要求：  
    - 唯一性：防止旧连接的延迟报文被误认为新连接的数据  
    - 不可预测性：防止攻击者猜测序列号并发起会话劫持  
    - 均匀分布：充分利用 32 位序列号空间（约 40 亿个可能）  
  现代安全算法：结合时间、连接信息和密码学哈希  

除了四次挥手，还有什么方法断开连接？
- RST

TCP 超时重传机制是为了解决什么问题？
  网络通信中的数据包丢失问题  

TCP 中何时会出现 RST（reset）报文？
  连接建立阶段：  
    目标端口为监听  
    队列满  
  连接终止阶段：  
    强制终止连接  
      应用层主动终止（进程崩溃）  
  TIME-WAIT 状态终止
  中间设备、安全策略  
  **RST 的设计初衷是处理异常**  

TCP 的 SACK 的引入是为了解决什么问题？
  选择性确认，接收方通过 SACK 选项告知发送方已收到的非连续数据块，避免重复传输  

ARP 和 RARP 分别是什么？有什么区别？
  ARP（Address Resolution Protocol，地址解析协议）和 RARP（Reverse Address Resolution Protocol，逆地址解析协议）
JWT Token 能说说吗？  
[JWT](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)  

常见的登录鉴权方式有哪些？各自的优缺点是？

### HTTP 与 HTTPS 的区别

#### 核心区别
| 特性               | HTTP                          | HTTPS                                      |
|--------------------|-------------------------------|--------------------------------------------|
| **安全性**         | 明文传输，无加密              | 通过 SSL/TLS 加密数据，防窃听和篡改        |
| **默认端口**       | 80                            | 443                                        |
| **协议栈**         | `HTTP → TCP`                 | `HTTP → SSL/TLS → TCP`                    |
| **证书**           | 无需证书                      | 需 CA 颁发的数字证书，验证服务器身份       |
| **性能**           | 无加密开销，理论更快          | 加密/解密带来轻微延迟（现代优化后影响小）  |
| **浏览器标记**     | 标记为“不安全”                | 显示安全锁图标                             |
| **SEO**            | 无优势                        | 搜索引擎优先索引                           |

#### 详细说明
1. **加密机制**  
   - HTTPS 使用混合加密：  
     - **握手阶段**：非对称加密（如 RSA）交换密钥。  
     - **传输阶段**：对称加密（如 AES）加密数据。  

2. **应用场景**  
   - **HTTP**：静态内容（如新闻、博客）。  
   - **HTTPS**：登录、支付、隐私数据（如银行、电商）。  

3. **风险提示**  
   - 即使启用 HTTPS，若页面内混用 HTTP 资源（如脚本、图片），仍会触发浏览器警告（Mixed Content）。  

#### 为什么选择 HTTPS？
- 用户信任（避免“不安全”提示）。  
- 符合 GDPR 等隐私法规要求。  
- 防止运营商劫持或广告注入。  

### TCP 和 UDP 的区别

TCP 提供面向连接的（三次握手）、可靠的（序列号、确认应答、超时重传）数据传输。  
UDP 提供无连接的、尽最大努力的数据传输服务  
- 传输速率
    TCP 要建立连接和维护可靠性机制，传输速率相对较低  
- 流量控制  
    TCP 有流量控制和拥塞控制机制，能根据网络状态调整传输速率  
    UDP 没有流量控制，以固定速率发送数据   
- 通信模式  
    TCP 支持点对点通信  
    UDP 支持一对一、一对多、多对多、多对一  
- 首部开销  
    TCP 首部较大，至少 20 字节  
    UDP 首部 8 字节  
- 应用场景  
    TCP （高可靠传输）：HTTP、FTP、SMTP  
    UDP （高实时性）：视频会议、游戏、DNS 查询  

#### TCP 流量控制机制

TCP流量控制是一种端到端的协调机制，主要目的是防止发送方发送数据过快，导致接收方来不及接收处理，从而造成数据丢失。其核心是解决发送方与接收方速度不匹配的问题，确保接收方的缓冲区不会溢出。  

滑动窗口机制：  
- 接收窗口(rwnd)  
  接收方通过TCP头部中的Window字段告知发送方自己当前可用的缓冲区空间大小（单位字节）   
- 发送窗口  
  发送方实际可发送的数据量取接收窗口和自身拥塞窗口(cwnd)的较小值   
- 动态调整  
  当接收方应用程序读取数据后，接收窗口会增大并通过ACK通知发送方；当接收方处理不及时导致缓冲区填满时，会减小窗口值甚至设为0  

##### 关键问题

零窗口死锁问题
- TCP 使用持续计时器，发送方定期发送 1 字节 的窗口探测报文查询最新窗口大小  

糊涂窗口综合征
- 问题描述：  
  当接收方频繁通告小窗口时，会导致大量小包传输，降低效率  
- 解决方案：  
  Nagle算法（发送方累积小数据）或接收方延迟通告小窗口  

### 浏览器

#### Session、Cookie、Token 的区别

Cookie：  
存储在客户端的小型文本文件（通常<=4KB）  
服务器通过 Set-Cookie 响应头设置，浏览器后续请求自动携带  
可能被 XSS 或 CSRF 攻击窃取，可通过HttpOnly、Secure等属性提升安全性  
不可跨域(除非设置domain)  
保持用户登录状态、记住用户偏好设置等  

Session：  
存储在服务端，客户端仅保存 Session ID  
服务器创建会话并生成唯一Session ID返回给客户端，客户端后续请求携带此ID  
相对安全(数据在服务端)，但需防范Session ID泄露  
分布式环境下需要特殊处理(如Session共享)  
需要跟踪用户状态的场景，如购物车、表单提交等  

Token：  
存储在客户端(如LocalStorage、Cookie或移动端本地存储)，服务端不保存Token本身  
服务器验证用户身份后生成Token返回，客户端后续请求在Header中携带此Token  
通常使用加密技术生成，较安全，但一旦签发难以主动失效  
API访问控制、单点登录(SSO)等  

### SSL/TLS协议

SSL,Secure Sockets Layer  
  主要用于解决 HTTP 明文传输的安全风险  
TLS,Transport Layer Security  
  SSL3.0 改进并标准化为 TLS1.0,逐渐取代 SSL    

SSL/TLS协议分为两层：  
- 记录协议层  
  作用：对上层数据分块、压缩、加密，并附加MAC值保证完整性  
  加密方式：采用对称加密（如AES）结合CBC模式，初始化向量（IV）由主密钥生成。  
- 握手协议层  

TLS握手流程  
1. ClientHello  
  客户端发送支持的TLS版本、随机数（Client Random）、密码套件列表（如TLS_AES_256_GCM_SHA384）和压缩方法  
2. ServerHello  
3. 密钥交换与验证  
4. 完成握手  

### HTTP

#### 版本改动

| **版本**     | **协议层**       | **关键特性**                                                                                                                              | **改进点**                                                                                   | **局限性**                                                 |
| ------------ | ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| **HTTP/1.0** | 基于 TCP         | - 短连接（每次请求需新建 TCP 连接）<br>- 支持缓存（Expires/Last-Modified）<br>- 无 Host 头字段                                            | 首次标准化 HTTP 协议，支持多种数据类型（如 HTML、图片）                                      | - 高延迟（频繁连接/断开）<br>- 队头阻塞（请求按顺序处理）  |
| **HTTP/1.1** | 基于 TCP         | - 默认长连接（Keep-Alive）<br>- 管道化传输（理论支持，默认关闭）<br>- 断点续传（Range 头）<br>- Host 头支持虚拟主机                       | - 减少 TCP 握手开销<br>- 支持部分资源请求                                                    | - 响应队头阻塞（服务器按顺序返回）<br>- 明文传输，安全性低 |
| **HTTP/2.0** | 基于 TCP + TLS   | - **二进制分帧**（Header/Data Frame）<br>- **多路复用**（单连接并发请求）<br>- **头部压缩（HPACK）**<br>- 服务端推送（Server Push）       | - 提升传输效率与带宽利用率<br>- 解决应用层队头阻塞                                           | - 仍依赖 TCP，存在传输层队头阻塞（丢包重传阻塞所有流）     |
| **HTTP/3.0** | 基于 QUIC（UDP） | - **基于 UDP 的 QUIC 协议**<br>- 多路复用（独立流，无队头阻塞）<br>- 头部压缩（QPACK）<br>- 0-RTT 快速握手<br>- 连接迁移（Connection ID） | - 彻底解决 TCP 队头阻塞<br>- 优化移动网络切换（如 IP 变化不影响连接）<br>- 集成 TLS 1.3 加密 | - 新协议兼容性需逐步完善<br>- UDP 可能被部分网络设备限制   |

#### HTTP3 选择了 UDP 的原因

- 解决了 TCP 的局限性  
  - 队头阻塞  
    TCP 要求数据包按序到达  
    UDP 无顺序约束，QUIC 协议通过独立的流实现多路复用，单个流丢包不影响其他流。  
  - 连接建立延迟  
    TCP 三次握手+TLS握手  
    QUIC 基于 UDP 实现 0-RTT 或 1-RTT 握手，显著降低延迟  
  - 协议僵化  
    TCP 协议栈内置操作系统内核，升级困难  
    QUIC 在用户空间实现  
- UDP 的灵活性以及 QUIC 的增强  
  - 可靠性增强  
    QUIC 通过 包编号、ACK 帧、快速重传，避免了 TCP 的重传模糊。  
  - 连接迁移  
    TCP 连接依赖四元组（IP+端口），网络切换要重连  
    QUIC 用 64 位连接 ID，IP 变化时仍可保持连接  
  - 内置加密  
    QUIC 默认集成 TLS 1.3  
- 适应现代网络需求  
  - 移动互联网以及弱网环境  
  - 多路复用与流优先级  
  - 绕过中间设备限制  
    新型传输协议常被防火墙拦截，UDP 广泛兼容，成本低  

## 计算机操作系统

[计算机操作系统知识总结](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md)

### 前端工程化

前端工程化是指将软件工程的技术和方法应用于前端开发，通过规范化、标准化和自动化的手段，提高开发效率、保障代码质量并降低维护成本。  
核心目标是解决四大问题：  
- 开发效率  
- 协作规范  
- 性能优化  
- 质量保障  

四大核心支柱：  
- 模块化  
    JS 模块化  
      CommonJS、AMD、CMD、ESM 等规范，解决全局变量污染、依赖管理问题  
    CSS 模块化  
      Sass/Less/Stylus 等预处理器，以及 CSS Module、CSS-in-JS  
    资源模块化  
      Webpack等工具将图片、字体也视为模块  
- 组件化  
- 规范化  
  代码规范  
  目录结构  
  工作流程  
  文档规范  
- 自动化  
  构建工具
  开发辅助

## 面试（）

### 多次

- JavaScript 类型判断
- 如何判断变量是数组

#### :key 的作用

:key 是 Vue 中的一个特殊属性，主要用于唯一标识虚拟DOM节点，帮助Vue更高效地更新和渲染DOM。它的主要作用包括：  
- 唯一标识元素身份  
  在列表渲染(v-for)或动态组件切换时，通过key可以精确识别每个节点 
- 优化渲染性能  
  通过key的比较，Vue可以复用已有DOM节点，减少不必要的DOM操作，将算法复杂度从O(n³)优化到O(n)  
- 保持组件状态  
  防止在列表更新时组件状态(如表单输入值)被意外重置或错乱 
- 正确触发过渡动画  
  在元素切换时，不同的key能确保Vue重新创建元素而非复用，从而触发过渡效果  

不使用 key 的后果：  
- 性能下降（无法高效复用）  
- 状态错乱  
- 渲染异常  

使用 index 作为key 的问题：  
当新插入的项目不在最后（eg：在开头插入，新插入的项目的 index 为 0， 则会导致后续的 index 都发生变化），无法达到提升渲染性能的目的。  

底层原理：  
Vue 的虚拟 DOM diff 算法  

### lingyi

#### 编写的 ts 是怎么转换成 js 的  

tsc  

#### 原型链

https://segmentfault.com/a/1190000042725370

原型（prototype）  
- 对象有__proto__属性，函数有__proto__属性，数组也有__proto__属性，只要是引用类型，就有__proto__属性，指向其原型。  
- 只有函数有prototype属性，指向new操作符加调用该函数创建的对象实例的原型对象。

原型链的形成  
- 当访问对象的属性时，若对象自身没有该属性，会通过 [[Prototype]] 逐级向上查找，直到找到或到达链的顶端 Object.prototype（其 [[Prototype]] 为 null）  
- person1.toString() 的查找路径为：person1 → Person.prototype → Object.prototype → null  


### xx

- [跨域](https://bakersean168.github.io/2025/03/02/CS/frontend/%E8%B7%A8%E5%9F%9F/)  
- tcp 和 udp
- https 
- 三次握手四次挥手

### tx

- vue中的 全局状态管理 和 props之类的父子间通信 的区别  
  数据被多个无关组件频繁使用时 全局  
- 正向代理与反向代理  
  正向代理是客户端的代理（个人翻墙、企业内网、内容过滤）；反向代理是服务器的代理（负载均衡、隐藏服务器、缓存加速）  
- pinia 和 vuex 的区别  
  - vuex 只有一个全局store，pinia 可以生成多个独立 store  
  - vuex 通过 mutations（同步）和 actions（异步）修改状态，结构严格但代码冗长；pinia 直接使用 action 处理同步和异步操作    
- pinia 的存储  
- cookie 和 localstorage 的区别  
- 前端工程化（webpack 打包、减小体积。。。）  
- 一句话讲一下 ts 的泛型  
  是一种创建可复用组件的工具，它允许我们在定义函数、接口或类时不预先指定具体类型，而是在使用时再指定，从而增强代码的灵活性和类型安全性。  
  

