---
tags:
  - tech/lang/algorithm
  - type/concept
  - status/growing
description: 二分查找算法三种写法(闭区间/左闭右开/开区间)
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[Algorithm MOC]]

---


# 二分算法 

## 二分查找

### 重点（三种写法）

### 闭区间

```js
// lowerBound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
var lowerBound = function(nums, target) {
    let left = 0, right = nums.length - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right+1] >= target
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] >= target) {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        } else {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        }
    }
    // 循环结束后 left = right+1
    // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
    // 所以 left 就是第一个 >= target 的元素下标
    return left;
}

var searchRange = function(nums, target) {
    const start = lowerBound(nums, target);
    if (start === nums.length || nums[start] !== target) {
        return [-1, -1]; // nums 中没有 target
    }
    // 如果 start 存在，那么 end 必定存在
    const end = lowerBound(nums, target + 1) - 1;
    return [start, end];
};
```

### 开区间

```js
// lowerBound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
var lowerBound = function(nums, target) {
    let left = -1, right = nums.length; // 开区间 (left, right)
    while (left + 1 < right) { // 区间不为空
        // 循环不变量：
        // nums[left] < target
        // nums[right] >= target
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] >= target) {
            right = mid; // 范围缩小到 (left, mid)
        } else {
            left = mid; // 范围缩小到 (mid, right)
        }
    }
    // 循环结束后 left+1 = right
    // 此时 nums[left] < target 而 nums[right] >= target
    // 所以 right 就是第一个 >= target 的元素下标
    return right;
}

var searchRange = function(nums, target) {
    const start = lowerBound(nums, target);
    if (start === nums.length || nums[start] !== target) {
        return [-1, -1]; // nums 中没有 target
    }
    // 如果 start 存在，那么 end 必定存在
    const end = lowerBound(nums, target + 1) - 1;
    return [start, end];
};
```

### you开zuo闭

```js
// lowerBound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
var lowerBound = function(nums, target) {
    let left = 0, right = nums.length; // 左闭右开区间 [left, right)
    while (left < right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right] >= target
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] >= target) {
            right = mid; // 范围缩小到 [left, mid)
        } else {
            left = mid + 1; // 范围缩小到 [mid+1, right)
        }
    }
    // 循环结束后 left = right
    // 此时 nums[left-1] < target 而 nums[left] = nums[right] >= target
    // 所以 left 就是第一个 >= target 的元素下标
    return left;
}

var searchRange = function(nums, target) {
    const start = lowerBound(nums, target);
    if (start === nums.length || nums[start] !== target) {
        return [-1, -1]; // nums 中没有 target
    }
    // 如果 start 存在，那么 end 必定存在
    const end = lowerBound(nums, target + 1) - 1;
    return [start, end];
};
```



## 二分答案

> “花费一个 log 的时间，增加了一个条件。” —— 二分答案

### 求最小

- [[使结果不超过阈值的最小除数]]

### 求最大

### 二分间接值

### 最小化最大值

### 最大化最小值

### 第 K 小/大

### 其他

## 信息参考

[二分查找 红蓝染色法【基础算法精讲 04】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=15c229538881316b8c6a43f997de056f)
