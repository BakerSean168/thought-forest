---
tags:
  - tech/lang/web
  - type/concept
  - status/growing
description: 浏览器Web Worker工作者线程原理
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[浏览器]] | [[ECMAScript MOC]]

---


# 浏览器工作者线程 

## 基础概念

### 工作者线程简介

JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分
配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、DOM，等等。每个页面就相当于
一个沙盒，不会干扰其他页面。对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。
使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境
不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码。

- 工作者线程是以实际线程实现的。
- 工作者线程并行执行。
- 工作者线程可以共享某些内存。  
  工作者线程能够使用 SharedArrayBuffer 在多个环境间共享内容。  
  虽然线程会使用锁实现并发控制，但 JavaScript 使用 Atomics 接口实现并发控制。
  工作者线程与线程有很多类似之处，但也有重要的区别。
- 工作者线程不共享全部内存
- 工作者线程不一定在同一个进程里
- 创建工作者线程的开销更大

#### 工作者线程的类型

1. 专用工作者线程
   专用工作者线程，通常简称为工作者线程、Web Worker 或 Worker，是一种实用的工具，可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它页面使用。
2. 共享工作者线程
   共享工作者线程与专用工作者线程非常相似。主要区别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。
3. 服务工作者线程
   服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。

#### WorkerGlobalScope

在网页上，window 对象可以向运行在其中的脚本暴露各种全局变量。  
在工作者线程内部，没有 window 的概念。  
这里的全局对象是 WorkerGlobalScope 的实例，通过 self 关键字暴露出来。

### 专用工作者线程

专用工作者线程是最简单的 Web 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）

#### 专用工作者线程的基本概念

可以把专用工作者线程称为后台脚本（background script）。  
JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。  
该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。

**创建专用工作者线程**
创建专用工作者线程最常见的方式是加载 JavaScript 文件。  
把文件路径提供给 Worker 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。  
传给构造函数的文件路径可以是多种形式。

```js
// emptyWorker.js
// 空的JS工作者线程文件

// main.js
console.log(location.href); // "https://example.com/"
const worker = new Worker(location.href + "emptyWorker.js");
console.log(worker); // Worker {}
// 这个例子非常简单，但涉及几个基本概念。
//  emptyWorker.js文件是从绝对路径加载的。根据应用程序的结构，使用绝对URL经常是多余的。
//  这个文件是在后台加载的，工作者线程的初始化完全独立于main.js。
//  工作者线程本身存在于一个独立的JavaScript环境中，因此main.js必须以Worker对象为代理实
// 现与工作者线程通信。在上面的例子中，该对象被赋值给了worker变量。
//  虽然相应的工作者线程可能还不存在，但该Worker对象已在原始环境中可用了。
// 前面的例子可修改为使用相对路径。不过，这要求main.js必须与emptyWorker.js在同一个路径下：
const worker = new Worker("./emptyWorker.js");
console.log(worker); // Worker {}
```

**工作者线程安全限制**
工作者线程的脚本文件只能从与父页面相同的源加载。  
从其他源加载工作者线程的脚本文件会导致错误。

**使用 Worker 对象**
Worker()构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。  
它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。

**DedicatedWorkerGlobalScope**  
在专用工作者线程内部，全局作用域是 DedicatedWorkerGlobalScope 的实例。  
因为这继承自 WorkerGlobalScope，所以包含它的所有属性和方法。  
工作者线程可以通过 self 关键字访问该全局作用域。

### 共享工作者进程

共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。

### 服务工作者进程

服务工作者线程（service worker）是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应。  
这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程缓存中提供服务。

## 使用指南

## 实战经验

## 经验总结

## 信息参考
