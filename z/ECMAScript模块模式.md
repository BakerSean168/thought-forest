---
tags:
  - tech/lang/javascript
  - type/concept
  - status/growing
description: JavaScript模块模式(CommonJS/ESM/AMD/UMD)
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:37
---

> [!info] **上级索引**
> [[ECMAScript MOC]] | [[前端工程化 MOC]]

---


# 模块模式

## 基础概念

### 核心思想

把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。

要解决的问题：

- 作用域隔离
- 私有共有分离
- 可复用

### 模块标识符

模块标识符是所有模块系统通用的概念。  
模块系统本质上是键/值实体，其中每个模块都有个可用于引用它的标识符。  
这个标识符在模拟模块的系统中可能是字符串，在原生实现的模块系统中可能是模块文件的实际路径。

### 模块依赖

模块系统的核心是管理依赖。  
指定依赖的模块与周围的环境会达成一种契约。  
本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块正常运行是必需的。  
模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。

### 模块加载

在浏览器中，加载模块涉及几个步骤。

- 加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。
- 如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回。
- 收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖。
- 然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成。
- 只有整个依赖图都加载完成，才可以执行入口模块。

### 入口

相互依赖的模块必须指定一个模块作为入口（entry point），这也是代码执行的起点。

### 异步依赖

可以让 JavaScript 通知模块系统在必要时加载新模块，并在模块加载完成后提供回调。

### 动态依赖

允许开发者在程序结构中动态添加依赖。

### 静态分析

模块中包含的发送到浏览器的 JavaScript 代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为。  
对静态分析友好的模块系统可以让模块打包系统更容易将代码处理为较少的文件。

### 循环依赖

要构建一个没有循环依赖的 JavaScript 应用程序几乎是不可能的，因此包括 CommonJS、AMD 和 ES6 在内的所有模块系统都支持循环依赖。

### 凑合的模块系统

为按照模块模式提供必要的封装，ES6 之前的模块有时候会使用函数作用域和立即调用函数表达式（IIFE，Immediately Invoked Function Expression）将模块定义封装在匿名闭包中。

### 使用 ES6 之前的模块加载器

[[CommonJS-AMD-UMD]]

### 使用 ES6 模块

ES6 最大的一个改进就是引入了模块规范。这个规范全方位简化了之前出现的模块加载器，原生浏
览器支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6 模块系统是集 AMD 和 CommonJS
之大成者。

从前面提到的使用 ES6 之前的模块加载器，可以发现一些不足：
在最初使用 script 导入的时期，容易造成变量混乱，现在有了模块级作用域；
运行时导入，难以静态分析、难以优化等。

默认导出和命名导出的哲学

**目的**：鼓励清晰的 API 设计，一个模块可以导出多个相关功能。

- 引入 module 类型
- 原生的 defer（在 html 中不会阻塞文档加载，等下载完按顺序执行）
- 模块只能加载一次。（一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次）模块代码只在加载后执行。
- 模块是单例。
- 模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。
- 模块可以请求加载其他模块。
- 支持循环依赖。

ES6 模块系统也增加了一些新行为。
- ES6 模块默认在严格模式下执行。
- ES6 模块不共享全局命名空间。
- 模块顶级 this 的值是 undefined（常规脚本中是 window）。
- 模块中的 var 声明不会添加到 window 对象。
- ES6 模块是异步加载和执行的

与`<script type="module">`关联或者通过 import 语句加载的 JavaScript 文件会被认定为模块。

> [!NOTE] ES6和COMMONJS对导入导出的值的修改
> - 在模块导出**基本类型数据**时，`require`方式无法获取内部最新数据而且修改变量值会脱钩，`import`方式外部无法修改模块的数据（只读引用），但是非默认导出属性可以获取内部最新值（通过导出的修改函数来修改的值，类似 class 的内部属性修改方法）。
> - 在模块导出**引用类型数据**时，外部和内部的修改都可以被观测到！

#### 模块标签及定义

ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。  
带有 type="module"属性的`<script>`标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。

- 所有模块都会像`<script defer>`加载的脚本一样按顺序执行。
  解析到`<script type="module">`标签后会立即下载模块文件，但执行会延迟到文档解析完成。
- 嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用 import 加载。  
  因此，嵌入模块只适合作为入口模块。

#### 模块加载

ECMAScript 6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。

完全支持 ECMAScript 6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。  
浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。  
这些文件通过网络返回后，浏览器就会解析它们的内容，确定它们的依赖，如果这些二级依赖还没有加载，则会发送更多请求。  
这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。

#### 模块行为

ES6 模块默认在严格模式下执行。

#### 模块导出

[[ES6模块导入导出方式]]

ES6 模块支持两种导出：命名导出和默认导出。

**命名导出**

- export 关键字用于声明一个值为命名导出
- 导出语句必须在模块顶级，不能嵌套在某个块中。
- 导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。
- 因为 ES6 命名导出可以将模块作为容器，所以可以在一个模块中声明多个命名导出。
- 导出的是值的引用，创建的是**实时绑定**（live binding）

**为什么是绑定 (Live Binding)**：

- **实时同步**：导入的值会随着原始值变化而变化
- **热重载友好**：开发时修改代码能立即反映
- **调试友好**：更容易追踪变量来源
- **性能考虑**：避免值拷贝

**目的**：鼓励清晰的 API 设计，一个模块可以导出多个相关功能。

**默认导出**
默认导出（default export）就好像模块与被导出的值是一回事。  
默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。
- 导出的是**值**（Value）的副本，而不是绑定；当原始变量改变时，默认导出的值保持不变

**为什么是值 (Value)**：

- **简单快捷**：适合导出单个主要对象
- **兼容性**：类似 CommonJS 的单出口
- **性能**：值拷贝通常更高效

**目的**：方便应用代码快速导入主要功能。

ES6 模块系统会识别作为别名提供的 default 关键字。此时，虽然对应的值是使用命名语法导出的，实际上则会成为默认导出：

```js
const foo = "foo";
// 等同于export default foo;
export { foo as default };
```

> [!NOTE] 命名导出与默认导出的哲学
> 这种"绑定 vs 值"的区别体现了语言设计者对**性能**、**开发体验**和**代码组织**的权衡。命名导出的绑定机制让代码更具动态性和可维护性，而默认导出的值机制提供了简单性和兼容性。

#### 模块导入

命名导出和默认导出的区别也反映在它们的导入上。

命名导出可以使用\*批量获取并赋值给保存导出集合的别名，而无须列出每个标识符：

```js
const foo = "foo",
  bar = "bar",
  baz = "baz";
export { foo, bar, baz };

import * as Foo from "./foo.js";
console.log(Foo.foo); // foo
console.log(Foo.bar); // bar
console.log(Foo.baz); // baz
```

要指名导入，需要把标识符放在 import 子句中。使用 import 子句可以为导入的值指定别名：

```js
import { foo, bar, baz as myBaz } from "./foo.js";
console.log(foo); // foo
console.log(bar); // bar
console.log(myBaz); // baz
```

默认导出就好像整个模块就是导出的值一样。可以使用 default 关键字并提供别名来导入。也可以不使用大括号，此时指定的标识符就是默认导出的别名：

```js
// 等效
import { default as foo } from "./foo.js";
import foo from "./foo.js";
```

如果模块同时导出了命名导出和默认导出，则可以在 import 语句中同时取得它们。可以依次列出特定导出的标识符来取得，也可以使用\*来取得：

```js
import foo, { bar, baz } from "./foo.js";
import { default as foo, bar, baz } from "./foo.js";
import foo, * as Foo from "./foo.js";
```

#### 模块转移导出

模块导入的值可以直接通过管道转移到导出。  
此时，也可以将默认导出转换为命名导出，或者相反。

## 需要了解什么

实现模块模式的方式有很多，现在主要的方式有两种，CommonJS 模块和 ES6 模块

下面主要讲讲两种模块的一些特性。

### CommonJS

- 使用 `require()` 指定依赖，使用 `exports` 定义自己的公共 API
- 无论一个模块在 require()中被引用多少次，模块永远是单例。
- 模块第一次加载后会被缓存，后续加载会取得缓存的模块。
- 模块加载是模块系统执行的同步操作。因此 require()可以以编程方式嵌入在模块中。
- 导入基本数据类型，属于复制，会被模块缓存，可以被重新赋值
- 导入引用数据类型，属于浅拷贝

### ES6

- 导出、导入方式更多，支持只引入必要内容
- 模块第一次加载后会被缓存，后续加载会取得缓存的模块。
- 导入的值是 动态只读引用，不能修改

### 区别

require 会将完整的 exports 对象引入，import 可以只引入必要的内容  
import 没有找到 export 的变量，在执行前就会报错，而 Common.js 在运行时才会报错  
commonJS 输出是值得拷贝 ES6 模块输出是值得引用  
commonJS 是运行时加载， ES6 模式是编译时输出接口  
commonJS require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段

