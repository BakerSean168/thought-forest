---
tags:
  - tech/lang/algorithm
  - type/concept
  - status/growing
description: 动态规划算法原理(递归/记忆化搜索/递推)
created: 2025-01-01T00:00:00
updated: 2025-12-07T21:16:36
---

> [!info] **上级索引**
> [[Algorithm MOC]]

---


# 动态规划

递归-》记忆化搜索-》递推

https://leetcode.cn/problems/house-robber/

递归+记忆化 ≈ 动态规划（自顶向下）
递推+状态存储 = 动态规划（自底向上）

```js
// 递归
var rob = function(nums) {
    let path = [];
    let res = [];

    let n = nums.length;
    let cache = new Array(n).fill(-1); // 遇到已经有记录的直接返回
    function dfs(i) {
        if (i < 0) {
            return 0;
        }
        if (cache[i] !== -1) {
            return cache[i];
        }
        res = Math.max(dfs(i-1), dfs(i-2) +nums[i])
        cache[i] =res; // 记录遇到的值，记忆化搜索
        return res;
    }
    return dfs(n-1);
};


// 递推
var rob = function(nums) {
        let n = nums.length;

    let f = new Array(n+2).fill(0);

    for (let i = 0; i<n;i++) {
        f[i+2] = Math.max(f[i+1], f[i]+nums[i])
    }
    return f[n+1];
};

```

## 入门

- 

## 01 背包 和 完全背包

完全背包状态转移方程：  
`dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]`

01背包：  
`dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]]`

选或不选 


什么时候要把状态定义成【前 i 个元素】中的最优值，什么时候要把状态定义成【以第 i 个元素结束】的最优值？  
如果是 01 背包或者最长公共子序列 LCS 那种，用【选或不选】思考的题目，要定义成【前 i 个元素】；  
如果是本节课讲的最长递增子序列 LIS 这种，用【枚举选哪个】思考的题目，要定义成【以第 i 个元素结束】。

### 至多装

### 恰好装

### 至少装

# 二维动态规划

## 最长回文子串

### Manacher 马拉车算法

https://www.bilibili.com/video/BV1UcyYY4EnQ/?vd_source=15c229538881316b8c6a43f997de056f

O(1) 判断任意字串是否回文  

核心思想：  
- 回文子串对称特征  

利用一个大范围回文子串和左侧小范围回文子串 --》 得到右侧小范围回文子串  

#### 细节

统一奇数长度和偶数长度回文子串写法：  
每个字符之间插入一个 #  

不写越界判断：  
前后插入一个 ^  
